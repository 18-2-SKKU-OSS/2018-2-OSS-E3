1 : 한글처리 알고리즘

-> 한국어 처리를 위해서 가장 처음에 해야할 일은 음절 글자를 음소단위로 쪼개는 일일 것입니다. Trie를 쓰기 위해서 자소 단위로 쪼개기로 함.

-> 유니코드를 사용하여 초성 중성 종성을 분리함.

 -> 
ㄱ~ㅎ, ㅏ~ㅣ 까지의 모든 자소 글자를 1~51까지의 코드에 대응시킴. 

해당 코드 : 
https://github.com/18-2-SKKU-OSS/2018-2-OSS-E3/blob/b3706d885467faa964fa7b591bc95ca381240b25/ModelGenerator/utils.py
61번줄

2 : 한국어 형태소 매칭을 위한 Trie 구조로 데이터를 담을 구조체 KTrie 정의하기

struct KTrie
{
#ifdef  _DEBUG
    static int rootID;
    int id;
#endif //  _DEBUG
 
    KTrie* next[51] = {nullptr,};
    KTrie* fail = nullptr;
    KTrie* exit = nullptr;
    int depth;
    KTrie(int depth = 0);
    ~KTrie();
    void build(const char* str);
    KTrie* findFail(char i) const;
    void fillFail();
    vector<pair<int, int>> searchAllPatterns(const vector<char>& str) const;
};

3 : 입력되는 한글데이터로 Trie 구축하기

#ifdef _DEBUG
int KTrie::rootID = 0;
#endif // _DEBUG
 
KTrie::KTrie(int _depth) : depth(_depth)
{
#ifdef _DEBUG
    id = rootID++;
#endif // DEBUG
 
}
 
 
KTrie::~KTrie()
{
    for (auto p : next)
    {
        if(p) delete p;
    }
}
 
void KTrie::build(const char * str) // trie 자료구조에 한글 저장히기
{
    assert(str);
    assert(str[0] < 52);
    if (!str[0])
    {
        exit = this;
        return;
    }
    int idx = str[0] - 1;
    if (!next[idx]) next[idx] = new KTrie(depth + 1);
    next[idx]->build(str + 1);
}
 
KTrie * KTrie::findFail(char i) const // 글자의 끝을 찾기 위한 
{
    assert(i < 51);
    if (!fail) // if this is Root
    {
        return (KTrie*)this;
    }
    else
    {
        if (fail->next[i]) // if 'i' node exists
        {
            return fail->next[i];
        }
        else // or loop for failure of this
        {
            return fail->findFail(i);
        }
    }
}
 
void KTrie::fillFail()
{
    for (int i = 0; i < 51; i++)
    {
        if (!next[i]) continue;
        next[i]->fail = findFail(i);
         
        auto n = this;
        while (!n->exit && n->fail)
        {
            n = n->fail;
        }
        exit = n->exit;
    }
    for (auto p : next)
    {
        if (p)
        {
            p->fillFail();
        }
    }
}
 
vector<pair<int, int>> KTrie::searchAllPatterns(const vector<char>& str) const // 저장한 단어의 패턴을 검색하는 함수
{
    vector<pair<int, int>> found;
    auto curTrie = this;
    int n = 0;
    for (auto c : str)
    {
        n++;
        assert(c < 52);
 
        while (!curTrie->next[c - 1]) // if curTrie has no exact node, goto fail
        {
            if(curTrie->fail) curTrie = curTrie->fail;
            else goto continueFor; // root node has no exact node, continue
        }
        // from this, curTrie has exact node
        curTrie = curTrie->next[c - 1];
        if (curTrie->exit) // if it has exit node, a pattern has found
        {
            found.emplace_back(n - curTrie->exit->depth, n);
        }
    continueFor:;
    }
    return found;
}

[아호-코라식 알고리즘] 참조 https://m.blog.naver.com/PostView.nhn?blogId=kks227&logNo=220992598966&proxyReferer=https%3A%2F%2Fwww.google.com%2F
참조

4 : 형태소 간의 결합과 불규칙 활용은 분석은 어떻게 ?

위의 아호-코라식 알고리즘을 이용한다고 해도 어간과 어미의 결합시 일어나는 불규칙 활용을 분석해내는 것은 불가능함. 따라서 대부분의 한국어의 결합의 형태인

규칙 활용을 이용함. (예시, 오다 + 왔다 =>> 오 + 았 + 다 so, ㅗ + ㅏ = ㅘ)

따라서 모든 결합 규칙들을 작성하고 사전에 만들어 놓은 다음에 메모리에 다 저장해두었다가 패턴 검색시에 이용함. 
(형태소 결합규칙사전 참조)



출처: https://bab2min.tistory.com/561?category=686456 [나의 큰 O는 logx야..]
